\section{Test Generation with \pynguin}\label{sec:approach}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NOTE: The figure showing Pynguin's components has been moved to the        %%
%% source file of Sec. 1 as a hack to place it on the top of the second page. %%
%% This is a hacky and fragile solution, however there is no other way to     %%
%% tell LaTeX to place it on top of page 2 (I'd appreciate if `acmart` would  %%
%% provide an option for this, though...                                      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% General information about Pynguin
%%
\Pynguin is written in Python
and requires at least Python~3.8 to run.
%
It can,
however,
generate unit tests also for Python projects
that are built for older versions of Python.
%
\Pynguin can be run as a standalone command-line application
or—which is recommended—inside a \toolname{Docker} container.
%
It is released under the GNU LGPL open-source licence.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\pynguin's Components}\label{sec:approach-internal}

%%
%% Reference the figure
%%
\Cref{fig:pynguin-components} shows the components of \pynguin 
and their interactions
throughout the test-generation process.
%

%%
%% Describe the analysis stage
%%
\Pynguin takes as input a Python module~(denoted
by \circled{1}
 in \cref{fig:pynguin-components}).\footnote{%
  Usually, a module in Python is equivalent to a source file.
  %
  We currently restrict the support to modules written in Python
  because of the necessary code instrumentation.%
}
%
It then analyses the module to extract information~\circled{2}.
%
The extracted information consists,
among others,
of the declared classes, functions, and methods.
%
From this information
\pynguin builds the so-called \emph{test cluster}~\cite{WL05}~\circled{3}.
%
The test cluster contains all information about the module under test,
most importantly,
which classes, functions, and methods are declared,
and what their parameters are.
%
Furthermore,
\pynguin inspects the modules
that are transitively included by the module under test~(shown
as the \emph{context} in \cref{fig:pynguin-components}, \circled{4}).
%
From the context,
\pynguin extracts the types they define
by searching for those class definitions
that are available in the namespace of the module under test.
%
These types are then used as input-type candidates
during the test-generation phase.
%
\Pynguin selects classes, methods, and functions
from the test cluster during the generation
to build the test cases.
%

%%
%% How the test-case generation works
%%
When constructing a test case,
\pynguin selects a function or method from the module under test.
%
Consider the example code snipped in \cref{lst:triangle}:
%
there is only one function in the module,
\lstinline[language=python]!triangle!,
which \pynguin selects as its target function.
%
It therefore adds a statement representing a method call to
\lstinline[language=python]!triangle!
to its internal test-case representation.
%
Afterwards,
\pynguin aims to fulfill the requirements of the function's parameters
in a backwards fashion.
%
In the example,
\pynguin knows from the type annotations
that \lstinline[language=python]!int! statements are required.
%
It therefore generates one to three variable assignment statements of the form
\lstinline[language=python]!var = <num>!
and adds them to the test case
before the function-call statement.
%
The number of \lstinline[language=python]!int! statements
as well as the generated values are chosen randomly by \pynguin,
because variable values can be used for more than one parameter.
%
\Cref{lst:test-triangle} shows two test cases
that have been created by this way.
%
In case a more complex object is required as a parameter,
\pynguin will attempt to generate it
by recursively fulfilling the parameters of the involved methods;
the necessary statements are also prepended
to the list of statements of the test case.
%
We provide a detailed example of this process in our previous work~\cite{LKF21}.
%

%%
%% Describe the test-generation and test-execution stage
%%
For test input generation~\circled{5}
the user can select between various well-established algorithms:
DynaMOSA~\cite{PKT18},
MIO~\cite{Arc17},
MOSA~\cite{PKT15},
random~\cite{PLE+07},
Whole Suite~\cite{FA13},
and Whole Suite with archive~\cite{RVA+17}.
%
Depending on the selected algorithm,
\pynguin generates one or many test cases.
%
It then executes the newly generated test cases
against the module under test
to measure the achieved coverage~\circled{6}.
%
Currently,
\pynguin can consider line or branch coverage as an optimisation goal
for its search algorithms.
%
To support other variants of coverage
one needs to provide further fitness functions;
further coverage criteria are planned for future work.
%
It is possible to select one sort of coverage for the optimisation
or a combination of many.
%
To measure coverage
we instrument Python's byte code on-the-fly to trace
which parts of the module under test have been executed by a generated test.
%
After evaluating fitness,
\pynguin continues with the next iteration of the test-generation algorithm.
%
This process stops
once a configurable stopping condition is satisfied, such as
a time limit or a predefined amount of algorithm iterations.
%
It is also possible to stop the generation
after all coverage goals have been met,
which means the generated tests achieve \SI{100}{\percent} coverage.
%

%%
%% Describe the assertion-generation stage and the export
%%
After the test-input generation
\pynguin optionally attempts to generate regression assertions~\cite{Xie06}
to not only execute the code under test
but also check its results~\circled{7}.
%
The approach implemented in \pynguin is based on mutation testing~\cite{FZ12}.
%
\Pynguin utilises a customised version of \MutPy~\cite{DH14}
to generate mutated versions from the original module under test~\circled{8}.
%
\MutPy executes the tests generated by the previous stage of \pynguin
against these mutants as well as the original module.
%
By tracing the values of object attributes and function returns,
\pynguin determines which values change on the mutated version,
compared to the original module.
%
For these values \pynguin generates assertions
that interpret the returned values on the original module
as the ground truth.
%
As a consequence,
the generated assertions are able to kill the aforementioned mutants
if they show different behaviour
compared to the original module.
%
An advantage of generating regression tests this way is
that it implicitly minimises the number of assertions
present in the resulting test cases.
%

%
Finally, \pynguin generates Python source code~\circled{9}
from its internal representation of the test cases
and exports the source code
in the style of the popular
\toolname{PyTest}\footnote{%
  \url{https://pytest.org}, last access 2022–02–10.%
} framework into a Python module~\circled{10}.
%
Further styles,
for example,
\texttt{unittest} from Python's standard API,
can also be integrated easily.
%

%%
%% Modular structure of Pynguin's components
%%
Each of the stages of \pynguin
is built as modular and as independent of the others
as possible.
%
\Pynguin itself is furthermore built with extendability in mind.
%
This allows to replace stages and components easily.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Using \pynguin}\label{sec:approach-usage}

%%
%% How to setup Pynguin
%%
\Pynguin is written in Python.
%
It can thus be either executed after checking out its source code
or—more conveniently—be installed
from the Python Package Index~(PyPI)\footnote{%
  \url{https://pypi.org/project/pynguin}, last accessed 2022–02–10.%
} via the \texttt{pip} utility tool.
%

%%
%% Pynguin provides a CLI but also an API.
%%
The primary usage of \pynguin is as a command-line application.
%
It also provides a rudimentary API
that allows controlling the framework from inside another application
without the need to launch an external process.
%
As future work
we plan to enhance \pynguin's public API
such that it can also be used as a library for test generation
within other projects
without the necessity to execute it as a standalone application.
%
Our presentation here,
however,
will only discuss the command-line interface.
%
We refer the interested reader to \pynguin's documentation\footnote{%
  \url{https://pynguin.readthedocs.io}, last accessed 2022–02–10.%
}, which describes the API.
%
One can get an overview of all command-line arguments
using the \verb!--help! option
after installing \pynguin:
%
\begin{lstlisting}[language=bash]
$ pynguin --help
\end{lstlisting}

%%
%% Note the user to not shoot themselves into their feet
%%
Please note that \pynguin requires the user
to set the environment variable \verb!PYNGUIN_DANGER_AWARE!;
\pynguin executes the code under test
with arbitrary random inputs.
%
Depending on the code under test
this can cause side effects and harm to the user's system.
%
By setting the environment variable to an arbitrary value
the user confirms to \pynguin that they are aware of this risk.
%

%%
%% Present the main command-line arguments
%%
The main arguments of \pynguin are \verb!--project-path!
to specify the path of the project
\pynguin should generate tests for,
\verb!--module-name! to specify the name of the module
to generate tests for,
and the \verb!--output-path!,
where \pynguin stores the generated test cases.
%
\Pynguin requires the user to set at least those three parameters;
all further arguments come with documented default values
yielded by the \verb!--help! parameter.
%

%%
%% Introduce the minimal example and how to run it with Pynguin
%%
Consider the example in \cref{lst:triangle},
saved to a module \texttt{triangle.py} in the current work directory.
%
One can now run \pynguin with minimal configuration options:
%
\begin{lstlisting}[language=bash]
$ pynguin \
    --project-path ./ \
    --output-path /tmp/pynguin-tests \
    --module-name triangle
\end{lstlisting}
%
This results in \pynguin generating test cases using DynaMOSA~(the current
default algorithm).
%
It stores them in files to the folder \texttt{/tmp/pynguin-tests}.
%
Now suppose that the user wants to generate tests for the same module
but with the MIO algorithm instead of DynaMOSA.
%
All they need to do is to add \verb!--algorithm MIO! to their command line:
%
\begin{lstlisting}[language=bash]
$ pynguin \
    --project-path ./ \
    --output-path /tmp/pynguin-results \
    --module-name triangle \
    --algorithm MIO
\end{lstlisting}
%
Similarly,
one can set further configuration options.
%
\Cref{lst:test-triangle} shows an excerpt of the generated result.\footnote{%
  Since the generation process is based on random numbers,
  the exact result might differ.
  It still should look similar.
}
%
The two shown test cases in the result
execute the \lstinline[language=python]!triangle! function
with different parameter values
to execute different branches of the function's implementation;
the test cases also provide assertions
that check on the returned value of the \lstinline[language=python]!triange!
function.
%
Please note that re-executing \pynguin will overwrite the resulting files.
%

\lstinputlisting[%
  float=t,%
  language=Python,%
  caption={A simple function checking for triangle properties.},%
  label={lst:triangle},%
]{examples/triangle.py}

\lstinputlisting[%
  float=t,%
  language=Python,%
  caption={An excerpt of the test cases generated by \pynguin.},%
  label={lst:test-triangle},%
]{examples/test_triangle.py}

%%
%% Hint user about Pynguin not writing messages in default settings
%%
In the aforementioned settings,
\pynguin will not print any output to the terminal.
%
A more verbose output can be achieved by adding the \texttt{-v}
or \texttt{-vv} parameter.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Dynamic Typing}\label{sec:approach-typing}

%%
%% What about dynamic typing?
%%
As Python is a dynamically typed language,
it does not require the user to specify any type information,
although recent versions of the language support annotations for such information.
%
\Pynguin aims to parse type annotations
from the source code if they are available~(configurable as a parameter
to \pynguin).
%
Any parsed information about parameter types of functions and methods
as well about their return types is incorporated into the test cluster.
%
The type information stored in the test cluster
allows \pynguin to select specific objects
to satisfy the requirements of the parameters
when generating test cases for a specific function or method.
%

%%
%% What to do without type annotations?
Besides extracting type information from annotations in the source code,
\pynguin can also be extended to query external type-inference tools.
%%
If no type annotations are available for the code under test
\pynguin considers all available types from the test cluster
as candidates during input generation.
%
In this case,
\pynguin currently selects one of the available types
from the test cluster randomly.
%
%

%%
%% Get back to the example
%%
Let us again consider the triangle-classification function
from \cref{lst:triangle}.
%
Suppose there were no type annotation present:
%
As a consequence,
\pynguin could only guess the types of the parameters
and might come up with objects of arbitrary types
available from the test cluster.
%
Since our example does neither define new types
nor import any modules,
only the so called \enquote{builtins} are available:
basic types such as \lstinline[language=python]!float!
or \lstinline[language=python]!str!.
%
Choosing parameter values of type \lstinline[language=python]!float! instead of
\lstinline[language=python]!int! would be a reasonable choice for this triangle
function.
%
However,
the following test case would also be valid for the Python language if
there is no type information available:
%
\begin{lstlisting}[language=python]
import example as module0

def test_case_2():
    list_0 = ["foo", "bar"]
    str_0 = module0.triangle(list_0, list_0, list_0)
    assert str_0 == "Equilateral triangle"
\end{lstlisting}

%
Checking the triangle type for a list of strings
is not a reasonable thing,
although the language would permit it.
%
Note that the above test case is valid
because it executes the program without crashes
and covers parts of the code of the \lstinline[language=python]!triangle!
function;
it therefore contributes towards the optimisation goal of high coverage.
%
However,
the test case also shows that coverage may not be a good metric
for the effects of types.
%
Using an unexpected type as an input
may often also simply lead to crashes of the program under test,
for example,
if the code attempts to access non-existing attributes.
%
Furthermore,
the lack of type information can also prevent \pynguin
from being able to instantiate the correct objects.
%
This simple example shows
that type information is crucial for test generation
to generate not only covering
but also valid and useful tests.
%
While we strongly advocate the usage of type annotations
to improve \pynguin's resulting test cases,
the use of alternative means such as type inference
is an open research problem.
%
Enabling future research to address this problem
is a core motivation for building \pynguin.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Extending \pynguin}\label{sec:approach-extend}

%%
%% Pynguin is extendable!
%%
\Pynguin is a framework
that allows easy extension at various points.
%
Many extensions can be built by implementing
only few classes.
%
For example, adding a new test-generation algorithm
can be achieved by extending the abstract class
\sourcecode{TestGenerationStrategy}
and implementing its \sourcecode{generate\_tests} method.
%
It is also necessary to register the new algorithm
in the configuration and the algorithm instantiation.
%
The algorithm instantiation allows providing predefined operators
to the new algorithm
such as a factory for new chromosomes
or fitness functions for the search objectives.
%
We designed these components with evolutionary algorithms in mind;
one can of course also define purely random-based algorithms
as we have done with our Random algorithm,
based on the \toolname{Randoop} algorithm~\cite{PLE+07}.
%
\lstinputlisting[%
  float=t,%
  language=Python,%
  firstline=2, lastline=4
  caption={A random sampling strategy for test input generation.},%
  label={lst:randomsampling},%
]{examples/randomsampling.py}
%

%%
%% How could a minimal random-sampling algorithm be implemented?
%%
To demonstrate how simple this can be,
\cref{lst:randomsampling} implements an algorithm
that is based on random test-case sampling:
it generates a random test case by adding a method call
and its dependencies—the object to call the method on
as well as objects to fill the parameter values~(see Sec.~2 of our
previous work~\cite{LKF21} for a detailed illustration of this process).
%
Our example algorithm utilises the archive
that is also used for the MOSA~\cite{PKT15} algorithm
to store generated test cases
that cover certain coverage goals in order to keep track of them.
%
Now the algorithm loops until the stopping condition is fulfilled
or the test cases stored in the archive
cover all coverage goals.
%
In each loop iteration,
the algorithm randomly samples another test case.
%
It stores the new test case in the archive as well.
%
The given implementation also calls some helper methods
that keep track of the test-generation process;
for example,
they track the achieved coverage value
over the generation time.
%
In the end,
the example algorithm creates a test suite,
that is, a collection of the generated test cases,
and returns them back to the framework.
%
We already implemented this algorithm in \pynguin;
one can select it by setting
\verb!--algorithm RANDOM_TEST_CASE_SEARCH!.
%

%%
%% Note that this can be done with other components as well
%%
Similarly,
other parts of \pynguin can be extended.
%
Examples are test-case export in different styles
by implementing an AST visitor
or the incorporation of type-inference techniques
by querying external type-inference tools.
%

% vim: spelllang=en_GB
