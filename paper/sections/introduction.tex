\section{Introduction}\label{sec:introduction}
Advocates of Test Driven Development (TDD)  such a Harry Percival, the 
author of \cite{percival2014test}, argue that software developers should
 follow the TDD process in which they develop software by first writing tests,
then the bare minimum amount of code to make those tests pass,
before beginning the cycle anew with more tests.
%
On page 22 of \cite{percival2014test}, Percival advocates both functional and unit tests, making the following distinction:
“functional tests test the application from the outside, from the point of view
of the user. Unit tests test the application from the inside,
from the point of view of the programmer.”
%
Later, on page 470 of \cite{percival2014test}, Percival defines an “integration test” as
one that depends on and interacts with some external system.
%
“Integration test” is sometimes use in common vernacular in the same way that
Percival uses “functional test”.
%
This paper will do the same, using the terms interchangable.  The key point is
that such a test passes and calls many internal functions with potentially many
 different inputs to each.

In the author’s experience, immature organizations (or solo developers
on small or personal projects such as the author) often don’t adhere to the
 TDD approach, and end up writing the tests after the development of the code or
fail to write tests at all.
%
Alternatively, some teams may focus primarily on function tests
and opt not to develop unit tests, despite the pros (not to mention cons) of
each.
%
The main pros and cons for functional versus unit tests are summarized very
briefly in the short table below:
%
Since unit tests are tedious and time consuming to develop, the body of academic
work on generating them automatically is extensive, starting with classic
algorithms like search and randomization based \cite{Luk22Pynguin0170} and
rapidly expanding with the advent of generative AI 
\cite{bhatia2023unit,takerngsaksiri2024tdd,wang2024software}.
%
These AI methods generate tests based on a variety of inputs, typically the code
itself and some other input such as human prompts \cite{lahiri2023interactivecodegenerationtestdriven},
natural language requirements \cite{wang2024software}, or entire projects
\cite{rao2023cat}.

In the current research this author did not discover a deterministic (i.e.
non-generative AI) unit test generation paradigm that monitored live execution
of the code.
%
Thus, this work is perhaps most similar to 
\cite{lahiri2023interactivecodegenerationtestdriven}, though
differs in that rather than prompt users interactively for sample inputs and
outputs, it automatically detects such inputs, outputs, and changes in global
state by monitoring actual execution of the code.
%
The decorator is written in Python and requires at least Python 3.9 to run.
%
The decorator was developed and tested on a Windows 10 PC.  The author 
did not test it on *nix environments but given the cross-platform support of
Python, the author believes it should run in *nix environments with no more than
minor modifications.
%
The author releases it under the GNU LGPL open-source licence.
% vim: spelling=en_US