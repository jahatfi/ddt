\section{Introduction}\label{sec:introduction}



Advocates of Test Driven Development (TDD) such a Harry Percival
 \cite{percival2014test} argue that software developers should
follow the TDD process in which they develop software by first writing tests,
then the bare minimum amount of code to make those tests pass,
before beginning the cycle anew with more tests.
%
On page 22 \cite{percival2014test} Percival advocates both functional and
 unit tests, making the following distinction:
“functional tests test the application from the outside, from the point of view
of the user. Unit tests test the application from the inside,
from the point of view of the programmer.”
%
Later, on page 470 \cite{percival2014test} Percival defines an “integration test” as
one that depends on and interacts with some external system.
%
“Integration test” is sometimes used in common vernacular in the same way that
Percival uses “functional test”.
%
This paper will do the same, using the terms interchangably.  The author will 
even use the term "ad hoc test" in reference to informal tests used by the developer.  
The key asssumption for this paper is that there exists at least one passing 
test above the unit-level that calls more than one internal function.  This 
paper will describe how the work presented here grows more valuable the 
more functions are executed, and the more unique inputs are passed to each.
%
Previous academic research \cite{causevic2011factors, ramzan2024test} observed
 that industry TDD adoption is lower than desired,
reporting increased longer development cycles, skill issues, and legacy code as 
a few root factors, among others.
%
In constrast to the TDD methodology, 
others \cite{brown2013agility, shahabuddin2016integration} propose a 
integration-test-first approach (before unit tests)
as optimal for accelerating development 
and reducing a product's time to market due to the time-consuming nature of manually
developing unit tests \cite{kahur2023java, shahabuddin2016integration}.
Though Brown \textit{et. al.} 
acknowledge that integration and unit testing may go hand-in-hand, they 
ultimately argue in favor of the former before the latter \cite{brown2013agility}.  
Although implied by Brown \textit{et. al.}, Shahabuddin \textit{et. al.} 
\cite{shahabuddin2016integration} go so far as to explicitly argue that unit
testing can be performed \textit{after} initial product delivery to the customer.
%
This research corresponds with the author’s personal observations that immature 
organizations (or solo developers on small or personal projects)
 often don’t adhere to the  TDD approach, and end up writing the tests 
 after the development of the code or fail to write tests at all. In such cases,
 the hobbyist may focus primarily on function or integration tests
and opt not to develop unit tests, perhaps because the pros of unit tests
do not outweight the cons compared to a higher level test.
%
The main pros and cons for functional versus unit tests are summarized very
briefly Table 1.
\vskip .2cm
\noindent\begin{tabular}{|>{\centering\arraybackslash}m{0.6cm}|>{\centering\arraybackslash}m{3.4cm}|>{\centering\arraybackslash}m{3.4cm}|}
    \hline
    \multirow{2}{*}{} & \textbf{Functional Test(s)} & \textbf{Unit Test(s)} \\
    \hline
    \textbf{Pros} & \begin{itemize}[leftmargin=*]
        \item More relevant for the customer
        \item Efficiently tests modules together
        \item Less dependent to the internal unit implementations
    \end{itemize} & \begin{itemize}[leftmargin=*]
        \item Verifies individual components
        \item Efficient when testing single components
    \end{itemize} \\
    \hline
    \textbf{Cons} & \begin{itemize}[leftmargin=*]
        \item Waste of time when testing small unit changes
        \item May not accurately identify root cause of failure
    \end{itemize} & \begin{itemize}[leftmargin=*]
        \item Time consuming to develop
        \item Easily broken by refactoring code
    \end{itemize} \\
    \hline
\end{tabular}
\captionof{table}{Pros and Cons of Functional and Unit Tests}
Despite the time consuming nature of developing unit tests manually, both
TDD and integration-test-first proponents recognize value in \textit{having}
 unit tests. By definition, any reduction the cost of unit test creation drives 
up their return on investment.

\subsection{Previous work on automated test creation}\label{sec:intro-3}

Given the cost of creating valuable tests,
the body of academic work on generating them automatically 
via metaprogramming is extensive. Classic algorithms like search 
and randomization feature prominently in earlier work 
\cite{Luk22Pynguin0170}, with generative AI significantly increasing in 
popularity most recently
\cite{bhatia2023unit,takerngsaksiri2024tdd,wang2024software, kahur2023java}.
%
These AI methods generate tests based on a variety of inputs, typically the code
itself and some other input such as human prompts 
\cite{lahiri2023interactivecodegenerationtestdriven},
natural language requirements \cite{wang2024software}, or entire projects
\cite{rao2023cat}.  

While the results of such AI-generated tests are promising,
their coverage is not perfect \cite{kahur2023java} and still require significant
developer review and correction \cite{sundqvist2024ai}.  

Lemieux \textit{et. al.} propose a hybrid method that combines classic approaches
mutation with generative AI \cite{lemieux2023codamosa}.  Their work is 
impressive but still relies on search techniques that the work here does not.  

\subsection{Initial motivation}\label{sec:intro-4}

Not long ago the author sought to refactor a 6K+ line Python project - a static
analyzer for the C language. This project had no unit tests, 
only a single functional test designed by the author.
This sole test called most, if not all, of the functions defined within the 
project, if not directly, indirectly down the Function Call Graph.
Unit tests would have greatly eased the refactoring process and the author 
hypothesized that the metaprogramming abilities of Python might empower creation
of unit tests from that sole existing test. Within three months, he'd proven 
his hypothesis to be true by crafting a Python decorator that provides exactly
that function and and continues to refine this work to the present day.

\subsection{Organization of this paper}\label{sec:intro-5}

Section 2 of this paper describes the overall approach to building a
Python decorator to generate unit tests from existing tests. The subsequent
section enumerates both technical and philosophical assumptions made by the
author, as well as alternative approaches when those assumptions may not hold.
Section 4 follows to describe the three different approaches taken by the author to 
evaluate the generated tests, followed by a section dedicated to further 
discussion of this work compared and constrasted to more related work.  A short
conclusion follows, trailed by a brief Acknowledgements section.

% vim: spelling=en_US